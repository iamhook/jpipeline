### JPipeline
JPipeline - это аналог [Node-RED](https://github.com/node-red/node-red), написанный на Java.  
Представляет собой систему (сервер + клиент), предоставляющую возможность 
программирования потоков данных в графическом режиме.

<img src="../assets/images/main_menu.png" alt="Main menu" width="600"/>

## Потоковое программирование
Потоковое программирование (Flow-based programming, FBP) – это парадигма программирования, которая 
определяет приложения как сети процессов, представляющих собой 
«черные ящики» (узлы), которые обмениваются данными по предопределенным 
соединениям (дугам) посредством передачи сообщений. Узлы могут иметь входы и выходы. 
Принимая сообщение на выход, узел может произвести некоторые вычисления и 
отправить новое сообщение на выход. Эти узлы можно беско-нечно связывать 
между собой для формирования различных приложений без необходимости внутреннего изменения. 

## Модули
1. jpipeline-executor (`Исполнитель`) - серверное приложение, выполняющее потоки
2. jpipeline-manager (`Менеджер`) - серверное приложение, управляющее исполнителем
3. jpipeline-javafx-client (`Клиент`) - настольное приложение с пользовательским интерфейсом

| ![Диаграмма развертывания](../assets/images/deployment_diagram.png?raw=true) | 
|:--:| 
| *Диаграмма развертывания* |

## Процесс работы
### Экран входа
При запуске клиентского приложения открывается экран входа – здесь можно ввести данные для подключения 
к серверной части, при успехе данные сохраняются на диск для упрощения последующих подключений.

| ![Экран входа](../assets/images/login_menu.png?raw=true) | 
|:--:| 
| *Экран входа* |

### Основной экран
После успешного входа мы сразу попадаем на главный экран приложения.   
В центральной его части отображается рабочая область с расположенными на ней узлами – 
это графическое представление конфигурации, которую мы получили с сервера.
Узлы можно перемещать, удалять, соединять между собой и редактировать их свойства, пример меню редактирования будет представлен далее.  
В левой части расположено меню со списком доступных типов узлов. При нажатии на один из них он попадает на рабочую область.  
* удаление узла - клик `ПКМ` по узлу
* удаление связи - клик `ПКМ` по связи
* редактирование узла - двойной клик `ЛКМ` по узлу

В нижней части экрана находится панель инструментов, которая содержит кнопки для управления и статусы серверных приложений:
1. Кнопка `Deploy` - отправляет текущую конфигурацию потока на сервер и перезапускает поток
2. Кнопка `Reset` - сбрасывает текущую конфигурацию до той, что запущена на сервере в данный момент
3. Кнопка `Debug` - открывает меню отладки
4. Кнопка `Login` - открывает меню входа

| ![Основной экран](../assets/images/main_menu.png?raw=true) | 
|:--:| 
| *Основной экран* |

### Меню редактирования
При двойном клике `ЛКМ` по узлу на рабочей области открывается меню редактирования.  
Разработчик узла пишет меню редактирования сам, есть несколько способов:
1. Упрощенный `FXML`, поддерживаются только текстовые поля и выпадающие списки (пример - [ SplitNode](jpipeline-standart-nodes/src/main/resources/node-resources/SplitNode))
2. `FXML` + `Groovy` (deprecated) - произвольная разметка с помощью FXML и контроллер, написанный на Groovy (пример - [SwitchNode](jpipeline-standart-nodes/src/main/resources/node-resources/SwitchNode))
3. `HTML` + `JavaScript` (WebView) - используется HTML-файл, содержащий всю логику по отрисовке и обработке меню (пример - [SwitchNode](jpipeline-standart-nodes/src/main/resources/node-resources/SwitchNode))

| ![Меню редактирования SqlSelectNode](../assets/images/edit_menu_example.png?raw=true) | 
|:--:| 
| *Меню редактирования SqlSelectNode* |

| ![Меню редактирования SplitNode](../assets/images/edit_menu_example_2.png?raw=true) | 
|:--:| 
| *Меню редактирования SplitNode* |

### Меню отладки

По-умолчанию любое сообщение, приходящее на вход узлу `DebugNode`, будет отправлено в меню отладки.
Помимо этого, в классе [`Node`](jpipeline-common/src/main/java/com/jpipeline/common/entity/Node.java) 
в качестве логгера используется экземпляр класса [`JLogger`](jpipeline-common/src/main/java/com/jpipeline/common/util/JLogger.java), 
поэтому при использовании переменной `log` в вашем узле все вызовы `log.error()` и `log.debug() `
будут выводить сообщение так же и в меню отладки в пользовательском интерфейсе.

| ![Меню отладки](../assets/images/debug_menu.png?raw=true) | 
|:--:| 
| *Меню отладки* |

## Реализованные узлы
### InjectNode
Узел данного типа позволяет отправить сообщение, указанное в настройках, 
по нажатию специальной кнопки в интерфейсе пользователя.
| <img src="../assets/images/inject_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню InjectNode* |
### DelayNode
Позволяет искусственно замедлить поток, добавляя задержку для каждого сообщения относительно предыдущего. 
| ![Меню DelayNode](../assets/images/delay_node_menu.png?raw=true) | 
|:--:| 
| *Меню DelayNode* |
### FunctionNode
Позволяет написать функцию на Groovy, которая будет применяться к кажому входящему сообщению, 
результат будет отправлен следующему узлу. Таким образом, к примеру, 
можно перемещать свойства сообщения, удалять их или устанавливать новые.
| <img src="../assets/images/function_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню FunctionNode* |
### SwitchNode
Аналог оператора “switch”, доступного в большинстве языков программирования –
пользователь может указать определенные условия, по которым 
сообщение будет направляться на разные выходы узла.
| <img src="../assets/images/switch_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню SwitchNode* |
### JsonNode
Выполняет преобразование json-строк в объекты и наоборот.
| <img src="../assets/images/json_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню JsonNode* |
### SplitNode
Позволяет разделить входящее сообщение на несколько исходящих.  
Умеет:
* резделять строки с помощью указанного разделителя
* разделять массивы на подмассивы с указанными размером 
* разделять объект на несколько сообщений на основе его свойств

| <img src="../assets/images/split_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню SplitNode* |
### TemplateNode
Позволяет генерировать сообщения на основе текстового шаблона, используется синтаксис Mustache.
| <img src="../assets/images/template_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню TemplateNode* |
### ExecNode
Позволяет выполнить консольную команду, подстановка аргументов по Mustache-шаблону. 
Вывод команды отправляет в виде сообщения следующему узлу. 
| <img src="../assets/images/exec_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню ExecNode* |
### CounterNode
Каждое сообщение, проходящее через такой узел, увеличивает его внутренний 
счетчик на единицу. Значение счетчика пользователь видит в 
статусе этого узла. Имеет кнопку, нажатие которой сбрасывает счетчик. 
### SqlSelectNode
Позволяет выполнить SELECT-запрос к базе данных. 
Нет ограничений на типы баз данных, но необходимо загрузить 
jdbc-драйвер для нужной СУБД в папку с расширениями. 
На вход принимает сообщение, подставляя его поля в запрос. 
Имеет два режима работы:
* выборка целиком отправляется в одном сообщении
* одна запись – одно сообщение

| <img src="../assets/images/sql_select_node_menu.png?raw=true" width="500"/> | 
|:--:| 
| *Меню SqlSelectNode* |

## Запуск


## Разработка пользовательских узлов
Разработчикам доступна возможность создавать собственные узлы. 
Для этого необходимо поместить jar-файл с узлами в папку с расширениями на сервере (libs).

### Шаблон
Склонируйте проект [jpipeline-custom-nodes-template](https://github.com/iamhook/jpipeline-custom-nodes-template).
Этот проект содержит реализацию узла `HelloWorldNode`, на основе которой можно начать разработку своих узлов.

После разработки необходимо выполнить `./gradlew jar`. В папке `build/libs` появится jar-файл, 
который необходимо положить в папку с расширениями на сервере (при использовании docker-compose это ~/.jpipeline/libs на хостовой системе).


